Все команды с курса
https://stepik.org/lesson/806864/step/2?unit=810047



mkdir my-project — создаем папку my-project

cd my-project — заходим в папку my-project

git init . — инициализируем новый репозиторий из папки, где мы сейчас находимся (my-project)

git status – отображает список измененных, добавленных и удаленных файлов

git add конкретный файл – добавляет указанные файлы в индекс (обязательно перед последующим коммитом)
или же
git add * = git add -А = git add . - добавляют в Индекс сразу все файлы

git reset – отменяет действие команды git add на файл

git commit -m "сообщение" – фиксирует добавленные в индекс изменения с определенным сообщением

ls .git – выводит содержимое папки .git

ls -la – выводит список файлов и папок

ll — это команда, которая используется для получения подробной информации о файлах и папках в текущем каталоге. Она эквивалентна команде ls -l

find .git/objects — покажет все файлы в указанной папке

git cat-file -p 40-значный_хэш — просмотреть содержимое файла
или же
git cat-file -p master(или main)^{tree} указывает на дерево, соответствующее последнему коммиту ветки main

echo "Cодержимое файла" > file1.txt(может быть люое расширение файла) - создает файл с указанным содержимым.
Стрелочка > означает, что те данные, которые мы указали после команды echo в кавычках, должны быть направлены (должны содержаться) в файл с именем file1.txt

nano имя_файла — запускает редактор nano. Ctrl+X, Ctrl+Y для сохранения изменений и Enter — для выхода из nano.

nano .gitignore - создание специального игнорируемого файла
В нем мы вручную перечислим шаблоны, соответствующие таким файлам, а также файлы, которые по какой-либо иной причине не должны попадать в коммиты.
Этот файл Git помечает для себя как файл, который необходимо игнорировать.
Пример:
*.txt
*.log
/log


git log
Команда git log является основным инструментом Git для изучения истории разработки. С ее помощью можно:

1) найти конкретную версию проекта (конкретный коммит)

2) определить кто, когда и какие изменения сделал

3) вспомнить хэш коммита, к которому нужно вернуться

4) фильтровать коммиты

5) просто проследить за историей развития проекта

Важно: история коммитов отображается в обратном хронологическом порядке —  наверху самый свежий коммит, а под ним более старые.
Для того, чтобы выйти из лога, достаточно нажать клавишу q (видимо если работать через консоль командной строки)

git log -число(-1 это последний коммит) — ограничит количество отображаемых коммитов указанным числом. Команда выводит столько последних коммитов, сколько мы ей укажем.
git log --pretty=medium — выводит лог в формате по умолчанию
git log --pretty=oneline — выводит лог в формате одной строки
git log --pretty=oneline --abbrev-commit  - сокращает идентификатор коммита

лучше всего использовать вместо git log --pretty=oneline --abbrev-commit эквивалент:
git log --oneline

git log --pretty=format:"%h %an %ae %s" - можно сгенерировать вывод информации по коммитам в более компактном и информативном виде (https://mirrors.edge.kernel.org/pub/software/scm/git/docs/git-log.html#_pretty_formats)

git log -p — отобразит разницу, внесенную в каждый коммит. Разница часто называется диффом, а аргумент -p иногда заменяют на --patch.

git log --stat — выводит список коммитов и под каждым коммитом показывает автора, дату, комментарий, файлы, количество добавленных (зеленые плюсики) и удаленных строк (красные минусики) в этих файлах, а также какие изменения были сделаны (changed, insertions). Кратко и четко.

git log --author="name" - найти коммиты определенного автора

git show НОМЕР ХЭША (полный или сокращенный) - просмотреть отдельный коммит


Команда git checkout работает с тремя объектами:

1) файлами
git checkout -- имя_файла — для отмены изменений в файлах, которые в статусе Modified, еще не закоммичены.
git restore имя_файла - восстановит файлы рабочего каталога до изменений

2) коммитами
git checkout хэш_коммита — переключает на указанный коммит.
HEAD — это указатель на самый последний коммит, который для Гита будет теперь самым свежим – первым, т.к. мы следуем по цепочке коммитов в обратном порядке, чтобы попасть к предыдущим коммитам.
git checkout - - после этой команды мы вернем состояние репозитория в ту точку, где были до перехода

3) ветками
Переключаясь на ветку, мы переключаемся на последний коммит, присутствующий в этой ветке. 
Следовательно, состояние нашего проекта будет напрямую ссылаться на конкретный коммит данной ветки, который по умолчанию всегда будет последним. 
Т.е. HEAD будет указывать на последний коммит, сделанный в текущей ветке.

Каждая ветка представляет собой ссылку на текущий коммит.
А HEAD — это ссылка, которая указывает на текущую ветку.
При переключении между ветками происходит переключение HEAD на указанную ветку.

Для возврата на прежнюю версию ветки master(main), в которой мы работали до прыжка, нам снова нужна команда git checkout имя_ветки — в нашем случае это master(main) (ветка-то у нас одна), но попадем мы уже именно в ее последнюю версию (Switched to branch 'master'('main'))

1. Изменения в последнем коммитеet 
git commit --amend - Данная команда отлично выручает, если мы уже сделали коммит и поняли, что неплохо было бы добавить еще кое-что существенное в этот последний коммит
git commit --amend — добавляет изменения в последний коммит с использованием текстового редактора

Команда git commit --amend запустит одновременно редактор с предложением изменить сообщение предыдущего коммита. 
Мы можем его изменить, если нужно. Для выхода с сохранением изменений используем команду

:wq

Если мы не собираемся менять сообщение, то к git commit --amend прописываем флаг --no-edit:

git commit --amend --no-edit
git commit --amend --no-edit — добавляет изменения в последний коммит без текстового редактора

Текстовый редактор для изменения сообщения открываться не будет, мы сразу получим единый коммит — пятый коммит заменит результаты четвертого, сам же и став четвертым.

Если к команде git commit --amend добавить ключ -m, то мы можем передать новый комментарий из командной строки, не открывая текстовый редактор.

Надо быть осторожными при использовании флага --amend с коммитами, доступными другим членам команды. Изменение коммита, доступного другому пользователю, может привести к путанице и длительным устранениям конфликтов при слиянии.
Чтобы продолжить разработку, необходимо вернуться к текущему состоянию проекта:

git checkout master

или

git checkout main


2. Изменение не последнего коммита (или нескольких коммитов)

1) Перемещение всех коммитов в стандартном режиме команды git rebase
git rebase имя_ветки
git rebase имя_ветки — объединяет изменения из разных веток, переносит коммиты текущей ветки на вершину переданной

В начале работы команда rebase в папке .git создала файл-ссылку ORIG_HEAD, в котором сохранила идентификатор, откуда была перенесена ветка fix. Посмотреть его можно командой:
cat .git/ORIG_HEAD

А команда git reset --hard ORIG_HEAD вернет ветку fix обратно.
git reset --hard ORIG_HEAD — возвращает ветку обратно (в простых ситуациях — ранее не было никаких откатов в предыдущее состояние)

git reflog название_ветки — выведет лог перемещений ветки, которой делали rebase. Нужно найти последний коммит ПЕРЕД ребейзом и перенести на него указатель ветки.

2) Изменение коммитов любой давности — git rebase -i или --interactive
git rebase -i или --interactive — редактирует любые старые коммиты
git rebase -i HEAD~2 — изменит историю последних двух коммитов.

Флаг -i дает возможность изменять коммиты в процессе, а не перемещать все коммиты, как в стандартном режиме команды git rebase.  
HEAD~2 означает, что мы указали нужное нам количество коммитов для изменения — два. Мы будем менять историю последних двух коммитов.

После того, как мы введем команду git rebase -i HEAD~2 откроется текстовый редактор. Он содержит описание команд, используемых в интерактивном режиме rebase, например:

r (reword) — переименовать коммит

e (edit) — изменить коммит

s (squash) — склеить два или больше коммитов

А сами коммиты в интерактивном режиме расположены в другом порядке, от более старого к новому.

Все изменения добавляем с помощью git add и коммитим с параметром --amend

git commit --amend
Если вы зашли в git commit -- amend и не поняли, что дальше делать, нажмите i. Измените коммит, потом нажмите Esc и введите wq, потом Enter.
После успешного коммита, следуя подсказке Гита, выполняем git rebase --continue

git checkout -b имя_ветки - Флаг -b означает, что необходимо создать ветку с указанным именем и сразу переключится на нее.



git diff — позволяет просматривать список изменений, внесенных в репозиторий. Отобразятся только изменения, не подготовленные для фиксации.

Для просмотра подготовленных изменений необходимо добавить флаг --staged:
git diff --staged

- между  Рабочим каталогом и Индексом (собственно git diff )

- между Индексом и последним коммитом ( git diff --staged )


Отмена коммитов
1) Откат в предыдущее состояние с помощью git reset
git reset хэш_коммита - Мы сбросим историю до указанного коммита, но оставим внесенные изменения в файлах
git reset --hard хэш_коммита - Мы сбросим историю до указанного коммита и вернем файлы к исходному состоянию

Вообще у команды git reset есть три режима:

1. git reset --soft (перемещение указателя HEAD)
Команда git reset --soft выполняет обновление указателя HEAD, и на этом операция сброса останавливается.
Команда требует флаг HEAD~ с указанием цифры — сколько коммитов мы хотим убрать:
add
git reset --soft HEAD~1 — уберет последний коммит
git reset --soft HEAD~2 — уберет два последних коммита

2. git reset --mixed (обновление Индекса), то же самое, что git reset
Команда git reset --mixed равносильна команде git reset. Она выполняет 2 вещи:
- отменяет последний коммит.
- отменяет добавление в Индекс всех файлов.

3. git reset --hard (обновление Рабочего каталога)

Команда git reset --hard приведет Рабочий каталог к тому же виду, что и Индекс. 
Т.е. мы отменим последний коммит и все незакоммиченные изменения, а файлы в репозитории будут совпадать с предыдущим коммитом.
Этот режим подразумевает потерю изменений, поэтому перед его выполнением мы обязаны проверять git status, чтобы убедиться что нет незакоммиченных изменений (или они не нужны).

Флаг --hard означает полное удаление. Если не указывать флаг --hard, то по умолчанию подразумевается флаг --mixed, т.е. коммит отменится, 
но не удалится, все изменения этого коммита переместятся в Рабочий каталог, так что с ними можно будет продолжить работать (исправить или отменить и выполнить новый коммит).

К команде git reset --hard также еще требуется флаг HEAD~:

git reset --hard HEAD~1 — уберет последний коммит

git reset --hard HEAD~2 — уберет два последних коммита

2) Удаление неотслеживаемых файлов с помощью git clean
Команда git clean — это инструмент для управления рабочим каталогом, используется для отмены изменений, не подтвержденных коммитами (используется для операций с неотслеживаемыми файлами). 
Отменить действие команды git clean нельзя, она обеспечивает окончательное удаление данных из файловой системы, поэтому перед выполнением убедитесь, что неотслеживаемые файлы действительно нужно удалить.

3) Отмена изменений с помощью git revert
В случаях, когда коммит уже отправлен коллегам, его удалить ( или отредактировать) уже сложнее. 
Локальную историю мы можем исправить, а вот если коммит получили другие разработчики и, возможно, уже сделали на его основе что-то еще, то отменить его у всех так просто не получится.

Тогда применяют команду git revert. Вместо удаления коммита из истории проекта она отменяет внесенные в нем изменения и добавляет новый коммит с полученным содержимым. 
В результате история в Git не теряется, что важно для надежной совместной работы.

git revert делает следующее:

1) смотрит, какие изменения указаны в коммите

2) создает новый коммит с противоположными изменениями

Конечно, так не совсем хорошо — сначала делать изменения в репозиторий, а потом их отменять, история разработки "загрязняется". 
Но делать нечего, в Гите нет команды "забрать назад коммит", а git revert может быть единственным приемлемым выходом.

Команда git revert используется, когда нужно отменить (обратить) изменения, внесенные в коммит, где бы он ни находился.
Вызвать команду можно на любой коммит, для этого мы используем git revert хэш_коммита (тот самый 40-символьный хэш, можно сокращенный хэш)

Например, у нас баг появился в проекте из-за конкретного коммита, и чтобы не переходить к этому коммиту вручную, исправлять его и выполнять новый коммит, мы используем git revert хэш_коммита. 
Так мы откатим проект до заданного коммита. Создастся новый коммит — копия коммита с предоставленным хэшем — и добавится к истории текущей ветки.

То есть, команда git revert отменяет вообще любой коммит из истории проекта, но не удаляет его.

Важно: git revert создает новый коммит который отменяет изменения внесенные в переданном коммите, но она не удаляет из истории коммиты.



Рассмотрим самый простой пример. Допустим, мы хотим отменить изменения предпоследнего коммита. 
Для этого мы проверяем, что нет незакоммиченых изменений в Рабочем каталоге. 
Если таковые имеются, надо их закоммитить (или удалить) и только потом делать реверт, иначе возникнет файловый конфликт.

Затем выполняем реверт последнего коммита:

git revert HEAD

HEAD — это самый последний коммит в ветке.

Чтобы выполнить реверт предпоследнего коммита, надо задать команду git revert HEAD~1

Откроется консольный редактор, в котором можно отредактировать то, что нужно. CTRL+X — для выхода из редактора. В английской раскладке жмем q и Enter. После закрытия редактора в терминале появится информация об успешном реверте.

Либо можно совсем без редактора:

git revert HEAD --no-edit

Чтобы убедиться, что все получилось, надо зайти в лог и проверить.



У команды git revert есть два крупных преимущества по сравнению с git reset:

1. git revert нисторию проекта и производит операцию, безопасную для коммитов;

2. объектом git revert выступает конкретный коммит, созданный в любой момент истории, а git reset всегда берет за точку отсчета текущий коммит. 
Если нам нужно отменить коммит (для удобства назовем его F) с помощью git reset, то мы должны сначала удалить все коммиты, поданные после коммита F, а затем выполнить их повторно.

Команда git revert — гораздо более удобный и безопасный способ отмены изменений.




git clone https://github.com/kotBantik/mysuperproject1 — клонирует удаленный репозиторий на локальную машину

git remote add origin https://github.com/kotBantik/something.git — связывает локальный репозиторий с удаленным репозиторием   

git push origin — отправляет коммиты на сервер

git remote add origin HEAD — отправляет на сервер текущую ветку со всеми коммитами, которые мы сделали в ней



Когда не проходит git push
Допустим, мы сделали новый коммит, пушим его (хотим отправить на сервер), а Гит в ответ выдает такое: rejected

Т.е. коммит отклонен, наш пуш не прошел. Разбираемся, почему так бывает.

Git устроен так, что локально мы можем коммитить сколько угодно. 
Но прежде чем отправить свои коммиты на сервер, нужно подтянуть новые коммиты с сервера — те самые, которые успели сделать наши коллеги. То есть сделать git pull.
Когда мы делаем git push, Git сначала проверяет — нет ли на сервере новых коммитов. 
Если они есть, то мы видим сообщение — "git push rejected". 
Значит, нам нужно сначала сделать git pull, а затем снова запушить. 
Если же при попытке пуша новых коммитов на сервере нет, то git push пройдет сразу и отправит наши коммиты на сервер.

Бывает так, что когда мы сделали локальный коммит, а после этого подтянули новые коммиты с сервера, у нас в терминале появляется мердж-коммит: "Merge branch 'master' of github.com:наш_аккаунт".
Мердж-коммит — это коммит, который не несет смысловой информации, кроме самого факта мерджа. В таких случаях делаем пулл с флажком ребейза:

git pull --rebase origin master

В этом случае локальный коммит окажется "поверх" нового коммита с сервера, а мердж-коммита не будет:

git pull --rebase origin master — данная команда заберет все изменения с удаленного origin, применит к локальному origin и сольет изменения в локальную ветку master.

После этого останется запушить коммит на сервер

И еще. Когда мы работаем в одиночку, то удаленный репозиторий нужен только для сохранения резервной копии, туда мы будем только пушить.
Но при работе в команде следует пушить коммиты почаще (коллеги быстрее получат доступ к новым изменениям) и пуллиться почаще (почаще получать свежие изменения).



Получаем изменения из удаленного репозитория: git fetch и git pull

Чтобы получить все изменения с удаленного репозитория, мы используем команду git fetch. 
Конечно, если мы делаем проект только для себя, то загружать изменения из удаленного репозитория в локальный нам не потребуется. 
Но если мы работаем в команде, то придется по несколько раз в день обновлять свой репозиторий, загружая в него коммиты, сделанные другими разработчиками.

git fetch origin — получим изменения из репозитория с именем origin. 
Если у нас несколько удаленных репозиториев, и мы хотим получить изменения с них, то используем параметр --all:

git fetch --all — получим изменения из всех подключенных удаленных репозиториев.

Команда git fetch не обновит Рабочий каталог в соответствии с удаленным репозиторием. 
Она обновит только объекты (указатели, ветки и теги) и скачает все необходимые файлы в папу .git/objects.

Чтобы переключиться на извлеченное содержимое, рекомендуется отдельно запустить команду git checkout, мы просмотрим коммиты, перед тем как интегрировать их в локальный репозиторий.

Итак, если хотим увидеть, над чем работают остальные, то извлекаем данные с помощью команды git fetch.
Эта команда  используется для синхронизации локальных объектов с этими же объектами в удаленном репозитории.

А вот чтобы получать изменения и сразу обновлять рабочую копию так, чтобы она соответствовала удаленному репозиторию, мы используем команду git pull

git fetch — считается "безопасным" вариантом, т.к. загружает удаленное содержимое, но не обновляет рабочее состояние локального репозитория, оставляя текущую работу нетронутой.
git pull — загружает удаленное содержимое для активной локальной ветки и сразу выполняет команду git merge, создавая коммит слияния для нового удаленного содержимого.

git pull origin — получит изменения из удаленного репозитория origin и обновит локальный репозиторий в соответствии с этими изменениями.


-----
Допустим, мы начали работать в компании над новым проектом. 
Склонировали полностью весь репозиторий, со всеми его файлами, коммитами, индексами и тому подобным. 
Поработали в нем, внесли изменения в локальный репозиторий (индексация и фиксация),  отправили произведенные изменения на удаленный сервер, на GitHub с помощью git push. 
Теперь все наработки, которые мы сделали на домашнем компьютере, оказались в считанные секунды помещенными на сервере GitHub, под бдительным оком Git.

То же самое сделали и другие участники команды.

На следующий день мы приходим на работу и хотим продолжить работать— воспользуемся командой git pull — увидим, что нового добавили наши коллеги. И продолжим работать.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Имейте ввиду: git pull  !=  git clone. Команда git clone копирует весь репозиторий целиком, как есть — со всеми его файлами. Команда  git pull копирует разницу между удаленным и локальным репозиторием.



Чтобы создать файл, прописываем в терминале команду touch имя_файла

Создадим новую бранчу(ветку) с любым именем (например, first), она будет точной копией ветки master на этом этапе. Ветка создается командой git branch имя_ветки.
git branch first — теперь у нас есть ветка first, точная копия master.

Для переключения между ветками используется команда:
git checkout имя_ветки_на_которую_переключаемся

git checkout -b имя_ветки, где b — расшифровывается как branch - одновременно создаст ветку имя_ветки и переключит нас на нее.



"Слияние" веток master и second, оно проводится командой git merge имя_ветки_в_которой_делали_изменения — "смерживание" веток.
В команде слияния указываем имя той ветки, которую хотим слить с текущей, в которой мы находимся на данный момент.

Переключаемся на ветку master, т.к. мы должны находиться в той ветке, в которую вносим изменения из другой ветки. А затем сделаем само слияние: git merge имя_ветки_в_которой_делали_изменения

Теперь ветка master имеет в себе все, что есть и в ветке second, последняя нам уже не нужна, поэтому ее можно удалить командой git branch -d имя_ветки.



Алиасы – это набор своих команд, которые по своей сути, короче чем базовые команды, которые мы можем добавлять сами.
Другими словами, это псевдонимы команд, они эквивалентны исходным командам.

Создадим алиас:

git config --global alias.hist "log --pretty=format:'%h - %an, %ar : %s' --graph --date=short"

после чего выведем команду git hist: результат как у git log --pretty=format:"%h - %an, %ar : %s"

Видим, что наш лог упорядочен в соответствии с теми настройками, что мы задали в config.

Мы создали алиас в локальном файле конфигурации.
Создавать и менять псевдонимы можно как в глобальных файлах (глобальный файл конфигурации расположен в $HOME/.gitconfig) так и в локальных файлах конфигурации (путь к локальному файлу конфигурации начинается с активного репозитория Git в /.git/config).



Что такое "форкнуть" репозиторий?

Форк (от англ. fork – вилка) – это точная копия репозитория, но только уже в нашем аккаунте на гитхабе. Fork — это тоже самое, что branch в Git. Только на гитхабе такой branch называется форком.
--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Создание веток

Как только мы делаем первый коммит, гит создает по умолчанию первую ветку – master. 
Но мы не хотим работать сразу в ней, пусть это будет наша эталонная ветка. 
Хотим отделиться от нее и работать на другой ветке, и если все в этой другой ветке нас устроит, тогда смержим ее и master.

Создать свою ветку можно двумя способами:

1. Команды git branch + git checkout

Это классический вариант создания ветки: сначала создаем ветку командой git branch имя_ветки, потом переходим на нее git checkout имя_ветки
С помощью git branch test1 мы создали ветку test1, а с помощью git checkout test1 мы переключились на нее.

2. Команда git checkout -b имя-ветки – создает ветку с указанным именем и автоматически переключает на нее

Команда git checkout умеет создавать ветки и сразу переключаться на них. 
Это намного удобнее, чем в первом способе: сначала создавать ветку, потом на нее прыгать. 
Поэтому второй способ является более популярным, так как задействует только одну команду git checkout со специальным ключом -b (означает ветку – branch).

Переключиться на любую локальную ветку можно с помощью команды git checkout имя_ветки.

Чтобы посмотреть, на какой ветке мы работаем, применяем команду git branch. 
Она также покажет локальные ветки, которые есть в текущей рабочей копии (рабочем каталоге).

git branch -v покажет текущее состояние веток.

git branch -r  покажет удаленные ветки на сервере.

Если вообще хотим посмотреть все существующие ветки и в локальном и удаленном репозитории, то к команде добавляем ключ -a (означает, что все – all): git branch -a.


git stash - Эта команда позволяет запомнить изменения, которые были на текущей ветке и мы можем спокойно перейти на другую ветку.

Рассмотрим подробнее варианты применения git stash.
1. Если мы не добавляли файл в индекс, тогда нам нужно добавить сначала файл в индекс:
g
полный вариант  git stash --include untracked
Такая запись означает, что мы добавляем в stash все файлы, которые имеем, включая не проиндексированные.

Поработали на другой ветке, вернулись в ветку test и хотим наши изменения извлечь, чтобы продолжить работать с ними дальше. 
Выполняем 2 действия:
 - смотрим список всех отложенных изменений командой git stash list
 - достаем изменения из стека и возвращаем их в рабочую копию командой git stash pop или git stash apply.
Первая команда забирает данные из stash и удаляет их оттуда, а вторая забирает, но не удаляет.

2. Если мы добавляли файл в индекс, то достаточно просто команды git stash

Таким образом, мы можем откладывать наши изменения перед переходом на новую ветку, а затем доставать их обратно.
Кстати, если мы захотим удалить все файлы, которые находятся в stash, то используем git stash clear.


git checkout -b имя-ветки – создает ветку с указанным именем и автоматически переключает на нее
git checkout имя-ветки – автоматически переключает на любую локальную ветку
git stash – откладывает изменения, не добавляя их в коммит
git stash list – показывает список всех отложенных изменений
git stash pop – забирает данные из stash и удаляет их
git stash apply – забирает данные из stash, но не удаляет их
git stash clear – удаляет все файлы, которые находятся в stash
git branch -a – показывает все существующие ветки и в локальном и удаленном репозитории
git branch -r  – показывает удаленные ветки на сервере

--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Слияние веток

!!!Мы должны находиться в той ветке, в которую мержим.!!!


Итак, мы поработали в ветке test, поняли, что получилась классная фича, хотим включить ее в основной продукт – главную ветку main (на рисунке она названа A). Делаем git merge test.

Важно! В merge указывает ту ветку, на которой работаем и которую хотим соединить с главной. 
Мы работали в test, значит ее и указываем. Команда git merge автоматически смерживает указанную ветку с main.

Допустим, мы хотим запушить ветку, которую мы создали у себя локально и которой еще нет в удаленном репозитории. 
Тогда в ответ на команду git push origin гит нам скажет в комментарии, что на гитхабе-то такой бранчи нет еще. А заодно даст подсказку, как это подправить:

git push --set-upstream origin имя_ветки

На нашем удаленном репозитории на гитхабе создастся эта бранча. 
Перейдя в репозиторий на гитхабе, мы увидим, что добавилась эта новая ветка с нашим локальным репозиторием и теми файлами, которые мы в нем насоздавали.

Важно!
Команда  git push origin имя_ветки – отправляет нашу ветку на сервер в удаленный репозиторий проекта на гитхаб, 
а уже там команда git merge имя_ветки – сливает нашу ветку с главной веткой в удаленном репозитории.

Мы также можем забрать себе на компьютер ветку с удаленного репозитория командой:

git checkout origin/имя-ветки -b имя-ветки

После работы в локальном репозитории могут оставаться различные ненужные (=неотслеживаемые) файлы.
Чтобы удалить все лишнее, используем команду git clean -f  для удаления всех untracked файлов или git clean -fd для удаления и файлов и папок.




Если мы пушим в пустой репозиторий:
git push -u origin имя_ветки

Данной командой мы создаем в удаленном репозитории ветку, соответствующую нашей локальной и связываем их: 
в удаленную ветку будет производиться push из локальной ветки, а из удаленной ветки будет производиться pull в локальную ветку.

Иногда используют команду git merge --abort, чтобы откатить состояние до того, что было до запуска слияния.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------

Удаление веток


Для того, чтобы удалить какую-то ветку, используем команду git branch с ключом -d (означает delete – удалить) и прописываем название удаляемой ветки:

git branch -d имя_ветки

Ветка будет удалена только если она полностью слита с какой-то другой веткой. В противном случае гит не даст нам ее удалить.

Бывает так, что мы создали какую-то ветку, сделали в ней коммит, но потом поняли, что нам не нравится, не хотим ее мержить.
Чтобы удалить эту локальную ветку, надо перейти на master (git checkout master) и стереть ее там:

git branch -D имя_ветки

В отличии от ключа -d ключ -D (тоже (означает delete) удалит ветку в любом случае, даже если в ней есть изменения, которые мы можем потерять. Останется только master.

А чтобы удалить ветку с сервера, надо выполнить пуш ветки, только с флагом --delete:

git push origin --delete имя_ветки


git branch – по умолчанию выводит список локальных веток. С ключами -r, -a можно вывести, соответственно, либо только удаленные ветки, либо все ветки.
git checkout – переключает пользователя на другую ветку
git branch -d имя_ветки – удаляет ветку, которая полностью слита с какой-то другой веткой
git branch -D имя_ветки – удаляет любую локальную ветку
git push origin --delete имя_ветки – удаляет ветку с сервера
git fetch / git fetch origin имя_ветки – стягивает информацию о ветках на сервере к нам на локальную машину.
git clean -f  – удаляет все неотслеживаемые файлы
git clean -fd – удаляет неотслеживаемые файлы и папки
git push -u имя_ветки – создает в удаленном репозитории ветку, соответствующую локальной ветке и обе связывает.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------
git init имя_каталога – создаст рабочий каталог имя_каталога с репозиторием .git



Флаг -m в команде git branch позволит это сделать. Например, если мы сейчас находимся на ветке second_second, то задав гиту команду git branch -m new_second, наша second_second станет new_second.

Если мы хотим переименовать другую ветку, то после флага -m сначала пишем название изменяемой ветки, а потом через пробел ее новое название:

git branch -m first new_first

cherry-pick номер_коммита позволяет брать коммит с одной ветки и повторять его на другой ветке.

--------------------------------------------------------------------------------------------------------------------------------------------------------------------
Для того, чтобы указать тег, надо зайти в локальный репозиторий:

cd имя_репозитория

git branch

git log --pretty=oneline (смотрим лог, где все не очень понятно, т.к. много версий)

ll (смотрим, что там за файлы в этом репозитории)

Хотим добавить 2 файла:

touch file1.txt file2.txt (данная команда создает файлы – их указываем через пробел)

Делаем им git add, git status, git commit и git push. Видим, что все хорошо, нам нравится, хотим сделать это первой версией:

git tag v1.0.0  – наша версия будет называться v1.0.0, если не назовем ее никак, то гит ничего нам не вернет.

Теперь запустим git tag, который покажет существующие версии:

git tag

Видим, что закладка произошла в текущий коммит, поэтому когда мы зайдем в лог:

git log --pretty=oneline

то увидим наш коммит в качестве начального. Если бы мы сделали tag после пуша, то на гитхабе тэга не будет, надо сделать push и ему тоже:

git push origin v1.0.0

Зайдя на гитхаб, мы увидим, что он теперь и там тоже. Нажав на него, мы откроем первую версию.

Чтобы стереть тэг на локальной ветке:

git tag -d v1.0.0

Чтобы стереть тэг с гитхаба:

git push origin --delete v1.0.0

Хорошо, теперь сделаем закладку на следующую важную версию:

git checkout main (tag ставим всегда на main версии)

git pull (стягиваем себе то, что было смержено)

git branch (проверяем, что находимся на main)

git branch -D имя_ветки (удаляем ее в main)

git tag v1.2.0 (тэгируем новую версию)

git tag (проверяем, что она есть)

git push origin v1.2.0 (пушим в гитхаб)

Все. Теперь, если в нашем коде мы хотим перейти на первую версию, то нам уже не надо больше искать коммиты, надо просто смотреть, где есть тэги. Посмотрим теперь, сколько всего файлов:

ll

git log --pretty=oneline (смотрим в логе наш тэг v1.0.0)

git checkout v1.0.0 (переходим на наш коммит v1.0.0)

ll (смотрим, как выглядела 1-я версия)

git branch (проверим, на какой ветке находимся)

git checkout main (переходим на main, если были не на ней)

Натэгировать коммиты можно еще одним способом:

git tag v1.3.0 40-значный_SSH_коммита

Запушить все эти протэгированные коммиты можно сразу одним махом на гитхаб:

git push origin --tags

Вот такая полезная вещь)
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
На проекте иногда бывает так, что нужно узнать, кто и когда сделал тот или иной коммит, и git blame как раз и позволяет посмотреть, когда и какой "коммитер" редактировал те или иные строки файла в последний раз.

Следующая команда (используемый в ней параметр -L ограничивает вывод строками с 12 по 22 из этого файла) покажет краткий хэш коммита, автора, дату последнего изменения, номер строки и содержимое файла:

git blame -L 12,22 new-file.txt

Если для команды указать опцию -С, то можно увидеть, откуда определенные фрагменты кода появились изначально в репозитории, если они, конечно же, были откуда-то скопированы.

git blame -L 10,19 -C file3.php

Это очень полезно, т.к. мы получаем в качестве изначального коммит, в котором мы скопировали код. Это первый коммит, в котором мы обращаемся к этим строкам в этом файле. Но в данном случае Git сообщает нам первый коммит, в котором эти строки были написаны, даже если это было сделано в другом файле.